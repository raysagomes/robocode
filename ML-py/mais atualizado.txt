mais atualizado


package CyberSquad;

import robocode.*;
import java.awt.Color;
import java.awt.geom.Point2D;
import robocode.util.Utils;
import java.io.*;

public class Manivela extends AdvancedRobot {

    // Constants
    private static final double MIN_FIRE_POWER = 0.8;
    private static final double MAX_FIRE_DISTANCE = 300;
    private static final double FIRE_POWER_DECAY = 0.02;
    private static final double RADAR_TURN_ANGLE = 30;
    private static final double GUN_TURN_ANGLE = 10;

    // Variables
    double larguraArena;
    double alturaArena;
    boolean movendoParaFrente = true;
    ScannedRobotEvent alvo = null;
    boolean bloqueandoRadar = false;
    double oldEnemyHeading = 0;
    double amplitude = 50; // A amplitude do movimento oscilatório.
    double frequencia = 0.01; // A frequência do movimento oscilatório.
    double fase = 0; // A fase do movimento oscilatório.

    // File writing
    private PrintWriter writer;
    private boolean ganhouBatalha = false;

    // Robot configuration
    public void configurarRobo() {
        setColors(Color.red, Color.blue, Color.pink);
        larguraArena = getBattleFieldWidth();
        alturaArena = getBattleFieldHeight();
        setAdjustRadarForGunTurn(true);
        setAdjustRadarForRobotTurn(true);
        setAdjustGunForRobotTurn(true);
        setTurnRadarRight(360);

        try { 
            RobocodeFileOutputStream onScannerEventFile = new RobocodeFileOutputStream(getDataFile("coletandodados_data_onScannedRobot.csv"));
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(onScannerEventFile)));
            writer.println("Time;Event;Name;MyEnergie;MyGunHeat;MyGunHeading;MyHeading;MyRadarHeading;MyVelocity;EnemyName;Energy;Distance;Bearing;Heading;Velocity;Rank");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void run() {
        configurarRobo();
        while (true) {
            movimentoOscilatorio();
            rastrearAlvo();
            atirarNoAlvo();
            execute();
        }
    }

    // Método de movimento oscilatório
    public void movimentoOscilatorio() {
        double distancia = amplitude * Math.sin(frequencia * getTime() + fase);
        if (distancia > 0) {
            setAhead(distancia);
        } else {
            setBack(-distancia);
        }
        setTurnRight(5);
    }

    public void movimentoInteligente() {
        if (estaPertoDaParede() || estaPertoDeUmRobo()) {
            if (!estaPresoNaParede()) {
                movendoParaFrente = !movendoParaFrente;
            }
        }

        if (movendoParaFrente) {
            setAhead(100);
        } else {
            setBack(100);
        }

        if (alvo != null) {
            double angleToTarget = normalizeAngle(getHeading() - getGunHeading() + alvo.getBearing());
            setTurnRight(normalizeAngle(angleToTarget));
        }
    }

    public boolean estaPertoDeUmRobo() {
        return alvo != null && alvo.getDistance() < 100;
    }

    public void rastrearAlvo() {
        if (alvo != null) {
            double radarTurn = normalizeAngle(getHeading() + alvo.getBearing() - getRadarHeading());
            setTurnRadarRight(radarTurn);
            bloqueandoRadar = true;
        } else {
            setTurnRadarRight(RADAR_TURN_ANGLE);
        }
    }

    public double normalizeAngle(double angle) {
        while (angle > 180) {
            angle -= 360;
        }
        while (angle < -180) {
            angle += 360;
        }
        return angle;
    }

    public boolean estaPertoDaParede() {
        double x = getX();
        double y = getY();
        double angle = getHeading();
        double aheadDistance = 50;

        if (Math.abs(angle) < RADAR_TURN_ANGLE) {
            if (Math.abs(x - larguraArena / 2) < aheadDistance || Math.abs(y - alturaArena / 2) < aheadDistance) {
                return true;
            }
        } else if (Math.abs(angle) < RADAR_TURN_ANGLE * 2) {
            if (x <= 0 || y <= 0 || x >= larguraArena || y >= alturaArena) {
                return true;
            }
        }

        return false;
    }

    public boolean estaPresoNaParede() {
        double x = getX();
        double y = getY();
        double angle = getHeading();
        double aheadDistance = 50;

        if (Math.abs(angle) < RADAR_TURN_ANGLE) {
            if (Math.abs(x - larguraArena / 2) < aheadDistance && Math.abs(y - alturaArena / 2) < aheadDistance) {
                return true;
            }
        } else if (Math.abs(angle) < RADAR_TURN_ANGLE * 2) {
            if (x <= 0 || y <= 0 || x >= larguraArena || y >= alturaArena) {
                return true;
            }
        }

        if (x < 10 || x > larguraArena - 10 || y < 10 || y > alturaArena - 10) {
            double leftDistance = Math.min(Math.abs(x - 10), Math.abs(x - larguraArena + 10));
            double rightDistance = Math.min(Math.abs(y - 10), Math.abs(y - alturaArena + 10));
            if (leftDistance < aheadDistance && rightDistance < aheadDistance) {
                return true;
            }
        }

        return false;
    }

    public void atirarNoAlvo() {
        if (alvo != null) {
            double gunTurn = normalizeAngle(getHeading() - getGunHeading() + alvo.getBearing());
            setTurnGunRight(gunTurn);

            if (Math.abs(gunTurn) < GUN_TURN_ANGLE) {
                double firePower = Math.max(MIN_FIRE_POWER, getEnergy() * 0.1);
                double bulletSpeed = 20 - 3 * firePower;
                setFire(firePower);
                if (getEnergy() <= 0) {
                    setTurnGunRight(Double.POSITIVE_INFINITY);
                }
            }
        }
    }

 public void logDataScanner(String eventType, String enemyName, double energy, double distance, double bearing, double heading, double velocity) {
    if (writer != null) {
        // Format values and use dot (.) as the decimal separator
        String energyStr = String.format("%.2f", energy); // Format to 2 decimal places
        String gunHeatStr = String.format("%.2f", getGunHeat());
        String gunHeadingStr = String.format("%.2f", getGunHeading());
        String headingStr = String.format("%.2f", getHeading());
        String radarHeadingStr = String.format("%.2f", getRadarHeading());
        String velocityStr = String.format("%.2f", velocity);

        // Use semicolon (;) as the delimiter
        writer.printf("%d;%s;%s;%.2f;%.2f;%.2f;%.2f;%.2f;%.2f;%s;%s;%s;%s;%s;%s;%s%n",
                getTime(), eventType, getName(), energy, getGunHeat(), getGunHeading(), getHeading(), getRadarHeading(), getVelocity(),
                enemyName, energyStr, gunHeatStr, gunHeadingStr, headingStr, radarHeadingStr, velocityStr, ganhouBatalha ? "1st" : "0");
        writer.flush();
    }
}



@Override
public void onScannedRobot(ScannedRobotEvent e) {
    alvo = e;

    // Registre os dados do evento de digitalização
    logDataScanner("ScannedRobot", e.getName(), e.getEnergy(), e.getDistance(), e.getBearing(), e.getHeading(), e.getVelocity());

    // Lógica de aprendizado aqui:
    // Você pode usar as informações do evento de digitalização para ajustar o comportamento do robô

    // Por exemplo, você pode armazenar as informações sobre o comportamento do oponente,
    // como padrões de movimento, padrões de tiro, etc., e usá-las para tomar decisões melhores no futuro.
}

@Override
public void onHitRobot(HitRobotEvent e) {
    if (alvo != null && e.getName().equals(alvo.getName())) {
        double angleToTarget = normalizeAngle(getHeading() - getGunHeading() + alvo.getBearing());
        double newGunTurn = normalizeAngle(getGunHeading() - angleToTarget);
        setTurnGunRight(newGunTurn);
    } else {
        movendoParaFrente = !movendoParaFrente;
    }
}

@Override
public void onHitWall(HitWallEvent e) {
    movendoParaFrente = !movendoParaFrente;
}

@Override
public void onStatus(StatusEvent e) {
    if (bloqueandoRadar && getRadarTurnRemaining() == 0) {
        alvo = null;
    }
}

@Override
public void onDeath(DeathEvent event) {
    if (writer != null) {
        writer.close();
        writer = null;
    }
}

@Override
public void onWin(WinEvent event) {
    ganhouBatalha = true;
    if (writer != null) {
        writer.close();
        writer = null;
    }
} }

 
//





import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

# Função para carregar dados
def load_data(file):
    try:
        # Use semicolon (;) as the delimiter
        df = pd.read_csv(file, delimiter=';')

        # Replace commas with dots in specific columns (if necessary)
        for col in ['MyEnergie', 'MyGunHeat', 'MyGunHeading', 'MyHeading', 'MyRadarHeading']:
            df[col] = df[col].str.replace(',', '.', regex=True).astype(float)

        return df
    except FileNotFoundError:
        print(f"O arquivo {file} não foi encontrado.")
        return pd.DataFrame()
# Combine os dados em um único DataFrame
df = load_data('coletandodados_data_onScannedRobot.csv')

if not df.empty:
    # Imprima as colunas do DataFrame para verificar se estão corretas
    print("Colunas do DataFrame:")
    print(df.columns)

    # Adicione a coluna 'ganhou' (1 se ficou em primeiro, 0 caso contrário)
    df['ganhou'] = df['Rank'].apply(lambda x: 1 if x == '1st' else 0)

    # Exibir as primeiras linhas para verificar se a coluna foi adicionada corretamente
    print(df.head())

    # Separe as características e a variável alvo
    X = df[['MyEnergie', 'MyGunHeat', 'MyGunHeading', 'MyHeading', 'MyRadarHeading', 'MyVelocity',
            'Energy', 'Distance', 'Bearing', 'Heading', 'Velocity']]
    y = df['ganhou']

    # Normalização dos dados
    scaler = StandardScaler()
    X = scaler.fit_transform(X)

    # Divida os dados em conjuntos de treinamento e teste
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Crie e treine o modelo de regressão logística
    model = LogisticRegression()
    model.fit(X_train, y_train)

    # Faça previsões no conjunto de teste e avalie
    y_pred = model.predict(X_test)
    print(f"Acurácia: {accuracy_score(y_test, y_pred)}")

    # Verifique a distribuição dos dados
    print("Distribuição da coluna 'ganhou' no dataset completo:")
    print(df['ganhou'].value_counts())
    print("Distribuição da coluna 'ganhou' no conjunto de treinamento:")
    print(y_train.value_counts())
    print("Distribuição da coluna 'ganhou' no conjunto de teste:")
    print(y_test.value_counts())

    # Validação cruzada
    scores = cross_val_score(model, X, y, cv=5)
    print(f'Cross-validation scores: {scores}')
    print(f'Mean cross-validation score: {scores.mean()}')

    # Matriz de confusão
    cm = confusion_matrix(y_test, y_pred)
    print(f'Confusion Matrix:\n{cm}')

    # Relatório de classificação
    report = classification_report(y_test, y_pred)
    print(f'Classification Report:\n{report}')
else:
    print("Nenhum dado para treinar o modelo.")
 